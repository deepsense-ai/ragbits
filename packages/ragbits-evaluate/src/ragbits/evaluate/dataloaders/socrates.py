import ast
from collections.abc import Iterable

from ragbits.core.sources.base import Source
from ragbits.evaluate.dataloaders.base import DataLoader
from ragbits.evaluate.pipelines.socrates import SocratesData


class SocratesDataLoader(DataLoader[SocratesData]):
    """
    SOCRATES benchmark evaluation data loader.

    The source should point to a local/remote file exported from the
    Hugging Face dataset `soheeyang/SOCRATES`. Rows are expected to contain at least:
    - "r2(r1(e1)).prompt" (str) - the question
    - "e3.aliases" (str) - the possible answers (as a string representation of a tuple of lists)
    """

    def __init__(
        self,
        source: Source,
        *,
        split: str = "data",
        question_key: str = "r2(r1(e1)).prompt",
        answers_key: str = "e3.aliases",
    ) -> None:
        """
        Initialize the SOCRATES data loader.

        Args:
            source: The source to load the data from.
            split: The split to load the data from (file name generated by the source helper).
            question_key: Column name for the question.
            answers_key: Column name for possible answers.
        """
        required = {question_key, answers_key}
        super().__init__(source=source, split=split, required_keys=required)
        self.question_key = question_key
        self.answers_key = answers_key

    async def map(self, dataset: Iterable[dict]) -> Iterable[SocratesData]:
        """
        Map the dataset to the SOCRATES evaluation data schema.

        Args:
            dataset: The dataset to map.

        Returns:
            The SOCRATES evaluation data rows.
        """
        result = []
        for idx, row in enumerate(dataset):
            question_suffix = " ..."
            question = str(row.get(self.question_key, "")) + question_suffix
            possible_answers_raw = row.get(self.answers_key, "")

            try:
                possible_answers_tuple = ast.literal_eval(str(possible_answers_raw))
                possible_answers = [item for sublist in possible_answers_tuple for item in sublist]
            except (ValueError, SyntaxError) as e:
                raise ValueError(f"Invalid possible answers format: {possible_answers_raw}") from e

            result.append(
                SocratesData(
                    task_id=str(idx),
                    question=question,
                    possible_answers=possible_answers,
                )
            )

        return result
